* #Python
** Decorators
*** Decorator is a function that takes another function and extends the behavior of the latter function without explicitly modifying it.Eg:
#+BEGIN_SRC python

  def my_decorator(some_function):

      def wrapper():

          num = 10

          if num == 10:
              print("Yes!")
          else:
              print("No!")

          some_function()

          print("Something is happening after some_function() is called.")

      return wrapper


     def just_some_function():
        print("Wheee!")

  just_some_function = my_decorator(just_some_function)

  just_some_function()

     O/P:
     Yes!
     Wheee!
     Something is happening after some_function() is called.

#+END_SRC
*** Syntactic Sugar: Python allows you to simplify the calling of decorators using the @ symbol (this is called “pie” syntax).
    Continuing upper eg:
#+BEGIN_SRC python

from decorator07 import my_decorator

    @my_decorator
    def just_some_function():
    print("Wheee!")

    just_some_function()

#+END_SRC

*** Real World eg:
#+BEGIN_SRC python

from functools import wraps
from flask import g, request, redirect, url_for


def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if g.user is None:
            return redirect(url_for('login', next=request.url))
        return f(*args, **kwargs)
    return decorated_function


@app.route('/secret')
@login_required
def secret():
    pass

#+END_SRC
*** @functools.wraps: This simply preserves the metadata of the wrapped function. This is a convenience function for invoking update_wrapper() as a function decorator when defining a wrapper function. The main intended use for this function is in decorator functions which wrap the decorated function and return the wrapper. If the wrapper function is not updated, the metadata of the returned function will reflect the wrapper definition rather than the original function definition, which is typically less than helpful.Example:
#+BEGIN_SRC python

from functools import wraps
def my_decorator(f):
    @wraps(f)
   def wrapper(*args, **kwds):
       print('Calling decorated function')
       return f(*args, **kwds)
    return wrapper

@my_decorator
def example():
  """Docstring"""
     print('Called example function')
>>> example()
Calling decorated function
Called example function
>>> example.__name__
'example'
>>> example.__doc__
'Docstring'

#+END_SRC

** Iterator vs Iterable
*** In one perspective they are the same: You can iterate with a for loop over iterators and iterables. Every iterator is also an iterable, but not every iterable is an iterator. E.g. a list is iterable but a list is not an iterator! An iterator can be created from an iterable by using the function 'iter'. To make this possible the class of an object needs either a method '__iter__', which returns an iterator, or a '__getitem__' method with sequential indexes starting with 0. Iterators are objects with a '__next__' method, which will be used when the function 'next' is called.
*** Internal working of 'FOR' : The for statement calls iter() on the object ( which should be a so-called container object), which it is supposed to loop over. If this call is successful, the iter call will return return an iterator object that defines the method __next__() which accesses elements of the object one at a time. The __next__() method will raise a StopIteration exception, if there are no further elements available. The for loop whill terminate as soon as it catches a StopIteration exception. You can call the __next__() method using the next() built-in function.Eg:
#+BEGIN_SRC python

cities = ["Berlin", "Vienna", "Zurich"]
iterator_obj = iter(cities)
print(iterator_obj)
print(next(iterator_obj))
print(next(iterator_obj))
print(next(iterator_obj))
O/P:
34 iterable:  False
[4, 5] iterable:  True
(4, 5) iterable:  True
{'a': 4} iterable:  True
dfsdf iterable:  True
4.5 iterable:  False

#+END_SRC
*** If you want to add an iterator behavior to your class, you have to add the __iter__ and the __next__ method to your class. The __iter__ method returns an iterator object. If the class contains a __next__, it is enough for the __iter__ method to return self, i.e. a reference to itself:
#+BEGIN_SRC python

class Reverse:
    """
    Creates Iterators for looping over a sequence backwards.
    """

    def __init__(self, data):
        self.data = data
        self.index = len(data)
    def __iter__(self):
        return self
    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]
lst = [34, 978, 42]
lst_backwards = Reverse(lst)
for el in lst_backwards:
    print(el)
O/P:
42
978
34

#+END_SRC
** Merging two dictionaries
*** In Python 3.5+
#+BEGIN_SRC python
  x = {'a': 1, 'b': 2}
  y = {'b': 3, 'c': 4}

  z = {**x, **y}

  >>> z
  {'c': 4, 'a': 1, 'b': 3}
#+END_SRC

*** In Python 2.x
#+BEGIN_SRC python
  z = dict(x, **y)
  >>> z
  {'a': 1, 'c': 4, 'b': 3}

#+END_SRC
** Test multiple flags at once
#+BEGIN_SRC python

x, y, z = 0, 1, 0

if x == 1 or y == 1 or z == 1:
    print('passed')

if 1 in (x, y, z):
    print('passed')

# These only test for truthiness:
if x or y or z:
    print('passed')

if any((x, y, z)):
    print('passed')

#+END_SRC
** ASCII <-> Int <-> String
*** ord(char) -> converts ASCII char to int
    #+BEGIN_SRC python
    >>> ord("a")
    97
    #+END_SRC
*** chr(int) -> converts int to ASCII char
    #+BEGIN_SRC python
    >>> chr(97)
    'a'
    #+END_SRC
** SORTING
*** A simple ascending sort is very easy: just call the sorted() function. It returns a new sorted list:
    #+BEGIN_SRC python
    >>> sorted([5, 2, 3, 1, 4])
    [1, 2, 3, 4, 5]
    #+END_SRC
*** You can also use the list.sort() method. It modifies the list in-place (and returns None to avoid confusion). Usually it’s less convenient than sorted() - but if you don’t need the original list, it’s slightly more efficient.
    #+BEGIN_SRC python
    >>> a = [5, 2, 3, 1, 4]
    >>> a.sort()
    >>> a
    [1, 2, 3, 4, 5]
    #+END_SRC
*** Another difference is that the list.sort() method is only defined for lists. In contrast, the sorted() function accepts any iterable.
    #+BEGIN_SRC python
    >>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
    [1, 2, 3, 4, 5]
    #+END_SRC
*** Sorting complex objects using object's indices
    #+BEGIN_SRC python
    >>> student_tuples = [
            ('john', 'A', 15),
            ('jane', 'B', 12),
            ('dave', 'B', 10),
     ]
    >>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
    [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
    #+END_SRC
*** Sorting complex objects with named attributes
    #+BEGIN_SRC python
>>> class Student:
...     def __init__(self, name, grade, age):
...         self.name = name
...         self.grade = grade
...         self.age = age
...     def __repr__(self):
...         return repr((self.name, self.grade, self.age))

>>> student_objects = [
...     Student('john', 'A', 15),
...     Student('jane', 'B', 12),
...     Student('dave', 'B', 10),
... ]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
    #+END_SRC
*** Sorting using Operator module functions
    The operator module has itemgetter(), attrgetter(), and a methodcaller() function.
    #+BEGIN_SRC python
    >>> from operator import itemgetter, attrgetter

    >>> sorted(student_tuples, key=itemgetter(2))
    [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

    >>> sorted(student_objects, key=attrgetter('age'))
    [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
    #+END_SRC
    The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age:
    #+BEGIN_SRC python
    >>> sorted(student_tuples, key=itemgetter(1,2))
    [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

    >>> sorted(student_objects, key=attrgetter('grade', 'age'))
    [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]
    #+END_SRC
*** Ascending and Descending
    Both list.sort() and sorted() accept a reverse parameter with a boolean value. This is used to flag descending sorts. For example, to get the student data in reverse age order:
    #+BEGIN_SRC python
    >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
    [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
    >>> sorted(student_objects, key=attrgetter('age'), reverse=True)
    [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
    #+END_SRC
** Access one element at a time in List
*** Use *list to access one element at a time
    #+BEGIN_SRC python
    a=[1,2,3,4,5]
    print(*a)
    1 2 3 4 5
    #+END_SRC
** Itertools.groupby
*** Make an iterator that returns consecutive keys and groups from the iterable. The key is a function computing a key value for each element. If not specified or is None, key defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function.
    #+BEGIN_SRC python
    [k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B
    [list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D
    #+END_SRC
** Itertools.permutations
*** Return successive r length permutations of elements in the iterable.If r is not specified or is None, then r defaults to the length of the iterable and all possible full-length permutations are generated.Permutations are emitted in lexicographic sort order. So, if the input iterable is sorted, the permutation tuples will be produced in sorted order.Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation.
    #+BEGIN_SRC python
    permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC
    permutations(range(3)) --> 012 021 102 120 201 210
    #+END_SRC
** Itertools.combinations
*** Return r length subsequences of elements from the input iterable.Combinations are emitted in lexicographic sort order. So, if the input iterable is sorted, the combination tuples will be produced in sorted order.Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination.
    #+BEGIN_SRC python
    combinations('ABCD', 2) --> AB AC AD BC BD CD
    combinations(range(4), 3) --> 012 013 023 123
    #+END_SRC
** Regex
*** Searching substring
    #+BEGIN_SRC python
    >>> import re
    >>> x = re.search("cat","A cat and a rat can't be friends.")
    >>> print(x)
    <_sre.SRE_Match object at 0x7fd4bf238238>
    >>> x = re.search("cow","A cat and a rat can't be friends.")
    >>> print(x)
    None
    #+END_SRC
*** Searching any character
   The syntax of regular expressions supplies a metacharacter ".", which is used like a placeholder for "any character".
   #+BEGIN_SRC python

   In [126]: re.search(".ello","Hello")
   Out[157]: <_sre.SRE_Match object; span=(0, 5), match='Hello'>

   In [158]: re.search(".ello"," ello")
   Out[161]: <_sre.SRE_Match object; span=(0, 5), match=' ello'>

   In [162]: re.search(".ello","@ello")
   Out[165]: <_sre.SRE_Match object; span=(0, 5), match='@ello'>

   In [166]: re.search(".ello","ello")
   #+END_SRC
*** Searching within a character class
    Square brackets, "[" and "]", are used to include a character class. [xyz] means e.g. either an "x", an "y" or a "z".
    #+BEGIN_SRC python
    In [70]: re.search("S[abc]chin","Sachin")
    Out[122]: <_sre.SRE_Match object; span=(0, 6), match='Sachin'>

    In [123]: re.search("S[abc]chin","Sbchin")
    Out[123]: <_sre.SRE_Match object; span=(0, 6), match='Sbchin'>

    In [124]: re.search("S[abc]chin","Scchin")
    Out[124]: <_sre.SRE_Match object; span=(0, 6), match='Scchin'>

    In [125]: re.search("S[abc]chin","Sdchin")
    #+END_SRC
*** Instead of a choice between two characters, we often need a choice between larger character classes. We might need e.g. a class of letters between "a" and "e" or between "0" and "5".To manage such character classes the syntax of regular expressions supplies a metacharacter "-". [a-e] a simplified writing for [abcde] or [0-5] denotes [012345].So instead of [ABCDEFGHIJKLMNOPQRSTUVWXYZ] we can write [A-Z]. If this is not convincing: Write an expression for the character class "any lower case or uppercase letter" [A-Za-z]
