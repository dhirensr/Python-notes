* #Python
** Decorators
*** Decorator is a function that takes another function and extends the behavior of the latter function without explicitly modifying it.Eg:
#+BEGIN_SRC python

  def my_decorator(some_function):

      def wrapper():

          num = 10

          if num == 10:
              print("Yes!")
          else:
              print("No!")

          some_function()

          print("Something is happening after some_function() is called.")

      return wrapper


     def just_some_function():
        print("Wheee!")

  just_some_function = my_decorator(just_some_function)

  just_some_function()

     O/P:
     Yes!
     Wheee!
     Something is happening after some_function() is called.

#+END_SRC
*** Syntactic Sugar: Python allows you to simplify the calling of decorators using the @ symbol (this is called “pie” syntax).
    Continuing upper eg:
#+BEGIN_SRC python

from decorator07 import my_decorator

    @my_decorator
    def just_some_function():
    print("Wheee!")

    just_some_function()

#+END_SRC

*** Real World eg:
#+BEGIN_SRC python

from functools import wraps
from flask import g, request, redirect, url_for


def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if g.user is None:
            return redirect(url_for('login', next=request.url))
        return f(*args, **kwargs)
    return decorated_function


@app.route('/secret')
@login_required
def secret():
    pass

#+END_SRC
*** @functools.wraps: This simply preserves the metadata of the wrapped function. This is a convenience function for invoking update_wrapper() as a function decorator when defining a wrapper function. The main intended use for this function is in decorator functions which wrap the decorated function and return the wrapper. If the wrapper function is not updated, the metadata of the returned function will reflect the wrapper definition rather than the original function definition, which is typically less than helpful.Example:
#+BEGIN_SRC python

from functools import wraps
def my_decorator(f):
    @wraps(f)
   def wrapper(*args, **kwds):
       print('Calling decorated function')
       return f(*args, **kwds)
    return wrapper

@my_decorator
def example():
  """Docstring"""
     print('Called example function')
>>> example()
Calling decorated function
Called example function
>>> example.__name__
'example'
>>> example.__doc__
'Docstring'

#+END_SRC

** Iterator vs Iterable
*** In one perspective they are the same: You can iterate with a for loop over iterators and iterables. Every iterator is also an iterable, but not every iterable is an iterator. E.g. a list is iterable but a list is not an iterator! An iterator can be created from an iterable by using the function 'iter'. To make this possible the class of an object needs either a method '__iter__', which returns an iterator, or a '__getitem__' method with sequential indexes starting with 0. Iterators are objects with a '__next__' method, which will be used when the function 'next' is called.
*** Internal working of 'FOR' : The for statement calls iter() on the object ( which should be a so-called container object), which it is supposed to loop over. If this call is successful, the iter call will return return an iterator object that defines the method __next__() which accesses elements of the object one at a time. The __next__() method will raise a StopIteration exception, if there are no further elements available. The for loop whill terminate as soon as it catches a StopIteration exception. You can call the __next__() method using the next() built-in function.Eg:
#+BEGIN_SRC python

cities = ["Berlin", "Vienna", "Zurich"]
iterator_obj = iter(cities)
print(iterator_obj)
print(next(iterator_obj))
print(next(iterator_obj))
print(next(iterator_obj))
O/P:
34 iterable:  False
[4, 5] iterable:  True
(4, 5) iterable:  True
{'a': 4} iterable:  True
dfsdf iterable:  True
4.5 iterable:  False

#+END_SRC
*** If you want to add an iterator behavior to your class, you have to add the __iter__ and the __next__ method to your class. The __iter__ method returns an iterator object. If the class contains a __next__, it is enough for the __iter__ method to return self, i.e. a reference to itself:
#+BEGIN_SRC python

class Reverse:
    """
    Creates Iterators for looping over a sequence backwards.
    """

    def __init__(self, data):
        self.data = data
        self.index = len(data)
    def __iter__(self):
        return self
    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]
lst = [34, 978, 42]
lst_backwards = Reverse(lst)
for el in lst_backwards:
    print(el)
O/P:
42
978
34

#+END_SRC
** Merging two dictionaries
*** In Python 3.5+
#+BEGIN_SRC python
  x = {'a': 1, 'b': 2}
  y = {'b': 3, 'c': 4}

  z = {**x, **y}

  >>> z
  {'c': 4, 'a': 1, 'b': 3}
#+END_SRC

*** In Python 2.x
#+BEGIN_SRC python
  z = dict(x, **y)
  >>> z
  {'a': 1, 'c': 4, 'b': 3}

#+END_SRC
** Test multiple flags at once
#+BEGIN_SRC python

x, y, z = 0, 1, 0

if x == 1 or y == 1 or z == 1:
    print('passed')

if 1 in (x, y, z):
    print('passed')

# These only test for truthiness:
if x or y or z:
    print('passed')

if any((x, y, z)):
    print('passed')

#+END_SRC
** ASCII <-> Int <-> String
*** ord(char) -> converts ASCII char to int
    #+BEGIN_SRC python
    >>> ord("a")
    97
    #+END_SRC
*** chr(int) -> converts int to ASCII char
    #+BEGIN_SRC python
    >>> chr(97)
    'a'
    #+END_SRC
** SORTING
*** A simple ascending sort is very easy: just call the sorted() function. It returns a new sorted list:
    #+BEGIN_SRC python
    >>> sorted([5, 2, 3, 1, 4])
    [1, 2, 3, 4, 5]
    #+END_SRC
*** You can also use the list.sort() method. It modifies the list in-place (and returns None to avoid confusion). Usually it’s less convenient than sorted() - but if you don’t need the original list, it’s slightly more efficient.
    #+BEGIN_SRC python
    >>> a = [5, 2, 3, 1, 4]
    >>> a.sort()
    >>> a
    [1, 2, 3, 4, 5]
    #+END_SRC
*** Another difference is that the list.sort() method is only defined for lists. In contrast, the sorted() function accepts any iterable.
    #+BEGIN_SRC python
    >>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
    [1, 2, 3, 4, 5]
    #+END_SRC
*** Sorting complex objects using object's indices
    #+BEGIN_SRC python
    >>> student_tuples = [
            ('john', 'A', 15),
            ('jane', 'B', 12),
            ('dave', 'B', 10),
     ]
    >>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
    [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
    #+END_SRC
*** Sorting complex objects with named attributes
    #+BEGIN_SRC python
>>> class Student:
...     def __init__(self, name, grade, age):
...         self.name = name
...         self.grade = grade
...         self.age = age
...     def __repr__(self):
...         return repr((self.name, self.grade, self.age))

>>> student_objects = [
...     Student('john', 'A', 15),
...     Student('jane', 'B', 12),
...     Student('dave', 'B', 10),
... ]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
    #+END_SRC
*** Sorting using Operator module functions
    The operator module has itemgetter(), attrgetter(), and a methodcaller() function.
    #+BEGIN_SRC python
    >>> from operator import itemgetter, attrgetter

    >>> sorted(student_tuples, key=itemgetter(2))
    [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

    >>> sorted(student_objects, key=attrgetter('age'))
    [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
    #+END_SRC
    The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age:
    #+BEGIN_SRC python
    >>> sorted(student_tuples, key=itemgetter(1,2))
    [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

    >>> sorted(student_objects, key=attrgetter('grade', 'age'))
    [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]
    #+END_SRC
*** Ascending and Descending
    Both list.sort() and sorted() accept a reverse parameter with a boolean value. This is used to flag descending sorts. For example, to get the student data in reverse age order:
    #+BEGIN_SRC python
    >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
    [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
    >>> sorted(student_objects, key=attrgetter('age'), reverse=True)
    [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
    #+END_SRC
